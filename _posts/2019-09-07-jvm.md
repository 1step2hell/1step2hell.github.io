---
layout: post
title:  JVM
date:   2019-09-07 23:30:00 +0800
categories: Java
tags: JVM
published: false
---

* content
{:toc}

## 前言

JVM：Java Virtual Machine（Java 虚拟机）的缩写。  
JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆和一个存储方法域。 JVM屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在Java虚拟机上运行的目标代码（字节码）,就可以在多种平台上不加修改地运行。JVM在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。

## Java 虚拟机的生命周期

一个运行中的 Java 虚拟机有着一个清晰的任务：执行 Java 程序。程序开始执行时他才运行，程序结束时他就停止。你在同一台机器上运行三个程序，就会有三个运行中的 Java 虚拟机。

Java 虚拟机总是开始于一个 main() 方法，这个方法必须是公有、返回 void、只接受一个字符串数组。在程序执行时，你必须给 Java 虚拟机指明这个包含 main() 方法的类名。 Main() 方法是程序的起点，他被执行的线程初始化为程序的初始线程。程序中其他的线程都由他来启动。

Java 中的线程分为两种：守护线程（daemon）和普通线程（non-daemon）。守护线程是 Java 虚拟机自己使用的线程，比如负责垃圾收集的线程就是一个守护线程。当然，你也可以把自己的程序设置为守护线程。包含 Main() 方法的初始线程不是守护线程。 只要 Java 虚拟机中还有普通的线程在执行，Java 虚拟机就不会停止。如果有足够的权限，你可以调用 exit() 方法终止程序。

## Java 虚拟机的体系结构

在 Java 虚拟机的规范中定义了一系列的子系统、内存区域、数据类型和使用指南。这些组件构成了 Java 虚拟机的内部结构，他们不仅仅为 Java 虚拟机的实现提供了清晰的内部结构，更是严格规定了 Java 虚拟机实现的外部行为。

每一个 Java 虚拟机都由一个类加载器子系统（class loader subsystem），负责加载程序中的类型（类和接口），并赋予唯一的名字。每一个 Java 虚拟机都有一个执行引擎（execution engine）负责执行被加载类中包含的指令。

程序的执行需要一定的内存空间，如字节码、被加载类的其他额外信息、程序中的对象、方法的参数、返回值、本地变量、处理的中间变量等等。Java 虚拟机将这些信息统统保存在数据区（data areas）中。虽然每个 Java 虚拟机的实现中都包含数据区，但是 Java 虚拟机规范对数据区的规定却非常的抽象。

许多结构上的细节部分都留给了 Java 虚拟机实现者自己发挥。不同 Java 虚拟机实现上的内存结构千差万别。一部分实现可能占用很多内存，而其他以下可能只占用很少的内存；一些实现可能会使用虚拟内存，而其他的则不使用。这种比较精炼的 Java 虚拟机内存规约，可以使得 Java 虚拟机可以在广泛的平台上被实现。

数据区中的一部分是整个程序共有，其他部分被单独的线程控制。每一个 Java 虚拟机都包含方法区（method area）和堆（heap），他们都被整个程序共享。Java 虚拟机加载并解析一个类以后，将从类文件中解析出来的信息保存与方法区中。程序执行时创建的对象都保存在堆中。

当一个线程被创建时，会被分配只属于他自己的 PC 寄存器 “pc register”（程序计数器）和 Java 堆栈（Java stack）。当线程不调用本地方法时，PC 寄存器中保存线程执行的下一条指令。Java 堆栈保存了一个线程调用方法时的状态，包括本地变量、调用方法的 参数、返回值、处理的中间变量。

调用本地方法时的状态保存在本地方法堆栈中（native method stacks），可能在寄存器或者其他非平台独立的内存中。

Java 堆栈由堆栈块（stack frames (or frames)）组成。堆栈块包含 Java 方法调用的状态。当一个线程调用一个方法时，Java 虚拟机会将一个新的块压到 Java 堆栈中，当这个方法运行结束时，Java 虚拟机会将对应的块弹出并抛弃。

Java 虚拟机不使用寄存器保存计算的中间结果，而是用 Java 堆栈在存放中间结果。这使得 Java 虚拟机的指令更紧凑，也更容易在一个没有寄存器的设备上实现 Java 虚拟机。

## 类加载机制

classloader 有两种装载 class 的方式 （时机）：

* 隐式：运行过程中，碰到 new 方式生成对象时，隐式调用 classLoader 到 JVM
* 显式：通过 class.forname() 动态加载

站在 Java 虚拟机的角度来讲，只存在两种不同的类加载器：

1. 启动类加载器：它使用 C++ 实现（这里仅限于 Hotspot，也就是 JDK1.5 之后默认的虚拟机，有很多其他的虚拟机是用 Java 语言实现的），是虚拟机自身的一部分。
2. 所有其它的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类 java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。

站在Java开发人员的角度来看，类加载器可以大致划分为以下四类：

1. 启动类加载器： BootstrapClassLoader，负责加载存放在 $JDK\jre\lib 下，或被 -Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的 java. 开头的类均被 BootstrapClassLoader 加载）。启动类加载器是无法被 Java 程序直接引用的。
2. 扩展类加载器： ExtensionClassLoader，该加载器由 sun.misc.Launcher$ExtClassLoader 实现，它负责加载 $JDK\jre\lib\ext 目录中，或者由 java.ext.dirs 系统变量指定的路径中的所有类库（如 javax. 开头的类），开发者可以直接使用扩展类加载器。
3. 应用程序类加载器： ApplicationClassLoader，该类加载器由 sun.misc.Launcher$AppClassLoader 来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。
4. 自定义类加载器：JVM 自带的 ClassLoader 只是懂得从本地文件系统加载标准的 java class 文件，因此如果编写了自己的 ClassLoader，便可以做到如下几点：

    * 在执行非置信代码之前，自动验证数字签名。
    * 动态地创建符合用户特定需要的定制化构建类。
    * 从特定的场所取得 java class，例如数据库中和网络中。

JVM 类加载机制

* 全盘负责，当一个类加载器负责加载某个 Class 时，该 Class 所依赖的和引用的其他 Class 也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
* 父类委托（双亲委派模型），先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。
* 缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个 Class 时，类加载器先从缓存区寻找该 Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成 Class 对象，存入缓存区。这就是为什么修改了 Class后，必须重启 JVM，程序的修改才会生效。

### Parent Delegation Model(双亲委派模型)

// Todo.. [双亲委派模型：大厂高频面试题，轻松搞定](https://mp.weixin.qq.com/s/Dnr1jLebvBUHnziZzSfcrA)

使用双亲委派模型的好处：主要是为了安全性，避免用户自己编写的类动态替换 Java 的一些核心类，比如 String、Object，同时也避免了重复加载，因为 JVM 中区分不同类，不仅仅是根据类名，相同的 class 文件被不同的 ClassLoader 加载就是不同的两个类，如果相互转型的话会抛 java.lang.ClassCaseException。

### ThreadContextClassLoader 线程上下文类加载器

// Todo..

### SPI（Service Provider Interface）

// Todo..

## JVM 内存结构

![jvm_data_areas]({{'/styles/images/jvm/jvm_data_areas.png' | prepend: site.baseurl}}){:width="639" height="443"}

### Method Area（方法区）

属于共享内存区域，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

方法区有时被称为持久代（PermGen）。

### Heap（堆）

对于绝大多数应用来说，这块区域是 JVM 所管理的内存中最大的一块。线程共享，主要是存放对象实例和数组。内部会划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB)。可以位于物理上不连续的空间，但是逻辑上要连续。

由于现在垃圾收集器基本都是采用的分代收集算法，所以Java可以细分为：年轻代（Young Gen）和老年代(Tenured Gen)，而年轻代内存又被分成三部分：Eden空间、ServivorTo 空间、ServivorFrom 空间，默认情况下年轻代按照 8:1:1 的比例来分配。

OutOfMemoryError：如果堆中没有内存完成实例分配，并且堆也无法再扩展时，抛出该异常。

### Java Stack（Java 虚拟机栈）

线程私有，生命周期和线程一致。描述的是 Java 方法执行的内存模型：每个方法在执行时都会床创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。

局部变量表：存放了编译期可知的各种基本类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference 类型)和 returnAddress 类型(指向了一条字节码指令的地址)

StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度。
OutOfMemoryError：如果虚拟机栈可以动态扩展，而扩展时无法申请到足够的内存。

### Native Method Stack（本地方法栈）

区别于 Java 虚拟机栈的是，Java 虚拟机栈为虚拟机执行 Java 方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。也会有 StackOverflowError 和 OutOfMemoryError 异常。

### Program Counter Register（程序计数器）

内存空间小，线程私有。字节码解释器工作是就是通过改变这个计数器的值来选取下一条需要执行指令的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器完成

如果线程正在执行一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器的值则为 (Undefined)。此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。

### 运行时常量池

属于方法区一部分，用于存放编译期生成的各种字面量和符号引用。编译器和运行期(String 的 intern())都可以将常量放入池中。内存有限，无法申请时抛出 OutOfMemoryError。

### 直接内存

非虚拟机运行时数据区的部分。

在 JDK 1.4 中新加入 NIO (New Input/Output) 类，引入了一种基于通道(Channel)和缓存(Buffer)的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。可以避免在 Java 堆和 Native 堆中来回的数据耗时操作。

## Garbage Collection

### 对象存活判断

判断对象是否存活一般有两种方式：

* 引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。
* 可达性分析（Reachability Analysis）：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的。不可达对象。

在 Java 语言中，GC Roots 包括：

1. 虚拟机栈中引用的对象。
2. 方法区中类静态属性实体引用的对象。
3. 方法区中常量引用的对象。
4. 本地方法栈中 JNI 引用的对象。

### GC 算法

* 标记 -清除算法

  “标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。

  它的主要缺点有两个：一个是效率问题，标记和清除过程的效率都不高；另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

* 复制算法

  “复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

  这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，持续复制长生存期的对象则导致效率降低。

* 标记-压缩算法

  复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都 100% 存活的极端情况，所以在老年代一般不能直接选用这种算法。

  根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存

* 分代收集算法

  GC 分代的基本假设：绝大部分对象的生命周期都非常短暂，存活时间短。

  “分代收集”（Generational Collection）算法，把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。分区的目的：在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。

  **新生代**  
  存放新生的对象，占据堆的 1/3 空间，MinorGC（采用复制清除算法）进行垃圾回收。  
  新生代分 Eden、ServivorFrom、ServivorTo 三个区：
  * Eden：新对象的出生地。当Eden区内存不足的时候，虚拟机将进行一次 MinorGC。
  * ServivorTo：保留MinorGC过程中的幸存者。
  * ServivorFrom：上一次GC的幸存者，作为这一次GC的被扫描者。

  HotSpot 默认 Eden 与 Survivor 的大小比例是 8 : 1，也就是说 Eden : SurvivorFrom : SurvivorTo = 8:1:1。所以每次新生代可用内存空间为整个新生代容量的 90%,而剩下的 10% 用来存放回收后存活的对象。  
  当 Survivor 空间不够用时，则需要依赖其他内存(老年代)进行分配担保。

  MinorGC 的过程：MinorGC 采用复制算法。首先，把 Eden 和 ServivorFrom 区域中存活的对象复制到 ServicorTo 区域，同时把这些对象的年龄 +1（默认情况下 15 岁就直接送到老年代了）；然后，清空 Eden 和 ServicorFrom 中的对象；最后，ServicorTo 和 ServicorFrom 互换，原 ServicorTo 成为下一次 GC 时的 ServicorFrom 区。

  **老年代**  
  主要存放程序中年龄较大和需要占用大量连续内存空间的对象。
  老年代的对象比较稳定，所以 MajorGC 执行的频率较低。一般都是在空间不足的时候才会执行 MajorGC。
  MajorGC 采用标记—清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC 的耗时比较长，因为要扫描再回收。MajorGC 会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。
  当老年代装不下的时候，就会抛出 Out of Memory 异常。

  HotSpot 实现的复制算法流程如下:
  1. 当 Eden 区满的时候,会触发第一次 Minor gc,把还活着的对象拷贝到 Survivor From 区；当Eden区再次触发 Minor gc 的时候,会扫描 Eden 区和 From 区域,对两个区域进行垃圾回收,经过这次回收后还存活的对象,则直接复制到 To 区域,并将 Eden 和From 区域清空。
  2. 当后续 Eden 又发生 Minor gc 的时候,会对 Eden 和 To 区域进行垃圾回收,存活的对象复制到 From 区域,并将 Eden 和 To 区域清空。
  3. 部分对象会在 From 和 To 区域中复制来复制去,如此交换 15 次(由 JVM 参数 MaxTenuringThreshold 决定,这个参数默认是 15),最终如果还是存活,就存入到老年代。

  HotSpot GC 形象比喻版：
  1. 一个人（对象）出来（new 出来）后会在 Eden Space（伊甸园）无忧无虑的生活，直到 GC 到来打破了他们平静的生活。GC 会逐一问清楚每个对象的情况，有没有钱（此对象的引用）啊，因为 GC 想赚钱呀，有钱的才可以敲诈嘛。然后富人就会进入 Survivor Space（幸存者区），穷人的就直接 kill 掉。
  2. 并不是进入 Survivor Space（幸存者区）后就保证人身是安全的，但至少可以活段时间。GC 会定期（可以自定义）会对这些人进行敲诈，亿万富翁每次都给钱，敲诈 15 次后 GC 很满意，就让其进入了 Tenured Gen(养老区)。万元户经不住几次敲诈就没钱了，GC 看没有啥价值啦，就直接 kill 掉了。
  3. 进入到养老区的人基本就可以保证人身安全啦，但是亿万富豪有的也会挥霍成穷光蛋，只要钱没了，GC 还是 kill 掉。

### 垃圾收集器

如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。

* Serial 收集器

  串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。新生代、老年代使用串行回收；新生代复制算法、老年代标记-压缩；垃圾收集的过程中会 Stop The World（服务暂停）。

  ParNew 收集器 ParNew 收集器其实就是 Serial 收集器的多线程版本。新生代并行，老年代串行；新生代复制算法、老年代标记-压缩。

* Parallel收集器

  Parallel Scavenge 收集器类似 ParNew 收集器，Parallel 收集器更关注系统的吞吐量。可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC 的时间不大于多少毫秒或者比例；新生代复制算法、老年代标记-压缩。

* Parallel Old 收集器

  Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和“标记－整理”算法。这个收集器是在 JDK 1.6 中才开始提供。

* CMS 收集器
  CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的 Java 应用都集中在互联网站或 B/S 系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。

  从名字（包含“Mark Sweep”）上就可以看出 CMS 收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为 4 个步骤，包括：
  * 初始标记（CMS initial mark）
  * 并发标记（CMS concurrent mark）
  * 重新标记（CMS remark）
  * 并发清除（CMS concurrent sweep）

  其中初始标记、重新标记这两个步骤仍然需要 “Stop The World”。初始标记仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，并发标记阶段就是进行 GC Roots Tracing 的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。

  由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS 收集器的内存回收过程是与用户线程一起并发地执行。老年代收集器（新生代使用 ParNew）。

  优点: 并发收集、低停顿  
  缺点: 产生大量空间碎片、并发阶段会降低吞吐量

* G1 收集器

  G1 是目前技术发展的最前沿成果之一，HotSpot 开发团队赋予它的使命是未来可以替换掉 JDK1.5 中发布的 CMS 收集器。与 CMS 收集器相比 G1 收集器有以下特点：
  * 空间整合，G1 收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次 GC。
  * 可预测停顿，这是 G1 的另一大优势，降低停顿时间是 G1 和 CMS 的共同关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 N 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒，这几乎已经是实时 Java（RTSJ）的垃圾收集器的特征了。

  上面提到的垃圾收集器，收集的范围都是整个新生代或者老年代，而 G1 不再是这样。使用 G1 收集器时，Java 堆的内存布局与其他收集器有很大差别，它将整个 Java 堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合。

  G1 的新生代收集跟 ParNew 类似，当新生代占用达到一定比例的时候，开始出发收集。和 CMS 类似，G1 收集器收集老年代对象会有短暂停顿。

  收集步骤：
  1. 标记阶段，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the World Event)，并且会触发一次普通 Mintor GC。对应 GC log:GC pause (young) (inital-mark)
  2. Root Region Scanning，程序运行过程中会回收 survivor 区(存活到老年代)，这一过程必须在 young GC 之前完成。
  3. Concurrent Marking，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。
  4. Remark, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1 中采用了比 CMS 更快的初始快照算法:snapshot-at-the-beginning (SATB)。
  5. Copy/Clean up，多线程清除失活对象，会有 STW。G1 将回收区域的存活对象拷贝到新区域，清除 Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。

* ZGC（Z Garbage Collector）

  Java 11 包含一个全新的垃圾收集器 ZGC，它由 Oracle 开发，承诺在数 TB 的堆上具有非常低的暂停时间。  
  ZGC 是一款可伸缩(scalable)的低延迟(low latency garbage)、并发(concurrent)垃圾回收器，旨在实现以下几个目标：
  * 停顿时间不超过10ms
  * 停顿时间不随heap大小或存活对象大小增大而增大
  * 可以处理从几百兆到几T的内存大小

**引用**

* [Java中的JVM原理](https://www.cnblogs.com/eastday/p/8124580.html)
* [JVM 的 工作原理，层次结构 以及 GC工作原理](https://segmentfault.com/a/1190000002579346)
* [关于Jvm知识看这一篇就够了](https://zhuanlan.zhihu.com/p/34426768)
* [JVM堆——新生代，老年代，永久代，GC](https://blog.csdn.net/hotchange/article/details/79761845)
* [Minor GC、Major GC和Full GC之间的区别](https://blog.csdn.net/superviser3000/article/details/81664317)
* [JAVA11 - ZGC 特性](https://blog.csdn.net/Aria_Miazzy/article/details/86593684)
